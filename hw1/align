#!/usr/bin/env python
import optparse, sys
from collections import defaultdict
from pprint import pprint

import random

optparser = optparse.OptionParser()
optparser.add_option("-b", "--bitext", dest="bitext", default="data/dev-test-train.de-en", help="Parallel corpus (default data/dev-test-train.de-en)")
optparser.add_option("-t", "--threshold", dest="threshold", default=0.5, type="float", help="Threshold for aligning with Dice's coefficient (default=0.5)")
optparser.add_option("-n", "--num_sentences", dest="num_sents", default=sys.maxint, type="int", help="Number of sentences to use for training and alignment")
optparser.add_option("-i", "--EM_iterations", dest="EM_iter", default=1, type="int", help="Number of iterations of EM to use")

(opts, _) = optparser.parse_args()


bitext = [[sentence.strip().split() for sentence in pair.split(' ||| ')] for pair in open(opts.bitext)][:opts.num_sents]
alignment_table = {}
alignments = []


t_f_e = {}
for (f_s, e_s) in bitext:
  for e in set(e_s):
    t_f_e[e] = t_f_e.get(e, {})    
    for f in set(f_s):
      t_f_e[e][f] = t_f_e[e].get(f, 1.0)

for e in t_f_e:
  SUM = sum(t_f_e[e].values())
  for f in t_f_e[e]:
    t_f_e[e][f] /= SUM

sys.stderr.write("Finished initializing t(f|e)\n")

for EM in xrange(opts.EM_iter):
  sys.stderr.write("Beginning EM iteration "+str(EM)+"\n")
  count_f_e = {}
  total_e = defaultdict(int)
  for (f_s, e_s) in bitext:
    for f in set(f_s):
      n_f = f_s.count(f)
      total_s = 0
      for e in set(e_s):
        total_s += t_f_e[e][f] * n_f
        count_f_e[e] = count_f_e.get(e, defaultdict(int))
      for e in set(e_s):
        n_e = e_s.count(e)
        count_f_e[e][f] += t_f_e[e][f] * n_f * n_e / total_s
        total_e[e] += t_f_e[e][f] * n_f * n_e / total_s

  for e in total_e:
    for f in count_f_e[e]:
      t_f_e[e][f] = float(count_f_e[e][f]) / total_e[e]


sys.stderr.write("Finished EM. Writing out alignments.\n")
for (f_s, e_s) in bitext:
  align_sent = []
  for i,e in enumerate(e_s):
    f_dist = t_f_e[e]
    
    SUM = 0
    for f_word in f_s:
      SUM += f_dist[f_word]

    r = random.uniform(0, SUM)

    #print "r", r
    upto = 0
    for j,f in enumerate(f_s):
      #print f_dist[f], upto
      if upto + f_dist[f] > r:
        align_sent.append((j,i))
        break
      upto += f_dist[f]
  print " ".join([str(j)+"-"+str(i) for j,i in align_sent])
